{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation de Focus 2 Pr\u00e9ambule Tutoriels","title":"Index"},{"location":"#documentation-de-focus-2","text":"Pr\u00e9ambule Tutoriels","title":"Documentation de Focus 2"},{"location":"preambule/","text":"Pr\u00e9ambule Attention ce guide est en cours de construction. Nous nous effor\u00e7ons de l'alimenter en continue. Une remarque ? Une question ? un besoin de documentation ? N'h\u00e9sitez pas \u00e0 saisir une issue .","title":"Pr\u00e9ambule"},{"location":"preambule/#preambule","text":"Attention ce guide est en cours de construction. Nous nous effor\u00e7ons de l'alimenter en continue. Une remarque ? Une question ? un besoin de documentation ? N'h\u00e9sitez pas \u00e0 saisir une issue .","title":"Pr\u00e9ambule"},{"location":"tutorials/","text":"Tutoriels Ecran de d\u00e9tail Ecran de liste","title":"Index"},{"location":"tutorials/#tutoriels","text":"Ecran de d\u00e9tail Ecran de liste","title":"Tutoriels"},{"location":"tutorials/detail-page/","text":"Impl\u00e9menter une page de d\u00e9tail Objectifs L'objectif de cet exercise et de pouvoir afficher une page de d\u00e9tail d'un film. Elle est constitu\u00e9e : d'un header ( Cartridge ) d'une zone de navigation rapide ( Scrollspy ) d'un ou plusieurs blocks de d\u00e9tail ( Panel ) Une page de d\u00e9tail ressemble \u00e0 \u00e7a : Concepts focus manipul\u00e9s Le CoreStore Focus propose un store simple CoreStore qui permet de stocker n-noeuds par store. L'id\u00e9e est que chaque store couvre un th\u00e8me fonctionnel de l'application. Par exemple, un store movieStore qui aura les noeuds : resume , characteristics , actors . Chaque noeud aura plusieurs propri\u00e9t\u00e9s associ\u00e9s : value , status , error . Warning Le CoreStore pour savoir s'il accepte la payload d'une action se base uniquement sur le nom du noeud. Si plusieurs stores ont un noeud avec un nom identique, alors il n'y a pas moyen de les diff\u00e9rencier. Le ActionBuilder Le ActionBuilder va permettre de cr\u00e9er simplement une action qui va \u00e9changer avec le server pour charger ou sauvegarder des donn\u00e9es. Lors de l'ex\u00e9cution d'une action, les op\u00e9rations suivantes sont effectu\u00e9es : Modifie le statut du noeud avec la valeur de preLoading (par d\u00e9faut: loading ) et passe isLoading \u00e0 vrai Si shouldDumpStoreOnActionCall est \u00e0 vrai, alors vide la valeur du noeud Appel le service configur\u00e9 et lui donne la payload Si on a configur\u00e9 un postService , on lui donne le retour du service pour transformation Dispatch le resultat du serveur dans le store, met le statut du noeud \u00e0 status et isLoading \u00e0 faux En cas de retour HTTP avec un code d'erreur, on dispatch dans le champ error du noeud Exemple de configuration d'un builder : const action : payload = Promise void = actionBuilder ({ // Noeud cibl\u00e9 node : movieCharacteristics , // Statut pendant le chargement/sauvegarde preLoading : loading , // Service \u00e0 appeler service : movieServices . loadMovieCharacteristics , // Si on vide le noeud pendant le chargement shouldDumpStoreOnActionCall : true , // Transformation du retour server postService : identity , // Le statut du noeud \u00e0 la fin de l appel status : loaded }); Le FormMixin // TODO - d\u00e9crire le formMixin Cr\u00e9ation de la page Commen\u00e7ons par cr\u00e9er un dossier pour l'ensemble des composants de cette page de d\u00e9tail, dans notre dossier de vues: views . La mani\u00e8re dont vous organisez votre dossier de vues vous incombe, cependant une bonne pratique est de regrouper les vues par module puis par \u00e9cran. Dans notre cas, nous cr\u00e9ons le dossier : views/movies/movie-detail . Cr\u00e9ons notre composant parent : // app/views/movies/movie-detail/index.jsx // Libs import React , { PropTypes } from react ; export const MovieDetailPage = React . createClass ({ render () { const { id } = this . props ; return div { `Page de d\u00e9tail du movie ${ id } ` } /div ; } }); MovieDetailPage . propTypes = { id : PropTypes . number . isRequired }; Notre page de d\u00e9tail est pour l'instant tr\u00e8s simple, elle n'a qu'une prop , id , qui lui sera fournie par le routeur lorsque l'on navigue vers l'URI /#movies/{id} . Il faut donc cr\u00e9er un nouveau fichier pour les routes de movies : // app/routes/movie-routes.jsx // Libs import React from react ; // Components import { MovieDetailPage } from ../views/movies/movie-detail ; export const movieRoutes = [ { path : movies/:id , component : ({ params }) = MovieDetailPage id = { params . id } / } ]; Puis l'enregistrer aupr\u00e8s du router : // app/routes/index.js // Components import AppLayout from ../components/app-layout ; // Routes import { homeRoutes } from ./home-routes ; +++ import { movieRoutes } from ./movie-routes ; export default { path: `${__BASE_URL__}`, component: AppLayout, indexRoute: { onEnter: ({ params }, replace) = replace(`${__BASE_URL__}home`) }, --- childRoutes: [...homeRoutes] +++ childRoutes: [...homeRoutes, ...movieRoutes] }; Les pr\u00e9-requis pour l'\u00e9cran Cr\u00e9ation du store Dans le dossier app/stores de votre application cr\u00e9er un fichier movie-detail.js . // app/stores/movie-detail.js // Libs import { CoreStore } from focus-core/store ; // On cr\u00e9er une instance de ce store export const movieDetailStore = new CoreStore ({ movieCharacteristics : movieCharacteristics }); movieDetailStore . name = movieDetailStore ; Note Nous lui donnons un nom afin d'aider pour les messages de debug. Ce n'est pas obligatoire mais c'est mieux. Cr\u00e9ation des APIs Notre entit\u00e9 movie dispose de deux APIs de manipulation, un load et et un save . Il est necessaire de cr\u00e9er le fichier config/server/movies.js qui contient les URIs expos\u00e9es par l'API. Le mieux pour cela est d'utiliser le paquet focus-service-generator (il est configur\u00e9 avec le starter kit) Ex\u00e9cutez : npm run generate Cela va g\u00e9n\u00e9rer un fichier de la forme suivante : // app/config/server/generated/movies.js import apiDriverBuilder from ../../../utilities/api-driver ; // Movies export default apiDriverBuilder ({ getMovie : { url : __API_ROOT__ + /api/movie/${id} , method : GET }, updateMovie : { url : __API_ROOT__ + /api/movie/${id} , method : PUT } // [...] }); Appelons le load au chargement de la page de d\u00e9tail afin de disposer des donn\u00e9es dans le store et donc dans les vues : Note La signature des m\u00e9thodes API sont de la forme : (uriParam, bodyParam, misc) Cr\u00e9ation des services Dans le fichier app/services/movies.js on va ajouter une m\u00e9thode pour charger et sauvegarder un film : // app/services/movies.js // Apis import moviesApi from ../config/server/generated/movies ; export const movieServices = { loadMovieCharacteristics ( id ) { return moviesApi . getMovie ({ id }); }, updateMovieCharacteristics ( movie ) { const { id } = movie ; return moviesApi . updateMovie ({ id }, movie ); } }; Cr\u00e9ation des actions Cr\u00e9er un fichier pour les actions li\u00e9es \u00e0 votre entit\u00e9 // app/actions/movies.js // Libs import actionBuilder from focus-core/application/action-builder ; // Services import { movieServices } from ../services/movies ; export const movieActions = { movieCharacteristics : { load : actionBuilder ({ node : movieCharacteristics , service : movieServices . loadMovieCharacteristics , shouldDumpStoreOnActionCall : true , status : loaded }), save : actionBuilder ({ node : movieCharacteristics , service : movieServices . updateMovieCharacteristics , shouldDumpStoreOnActionCall : false , status : saved }) } }; Les composants de l'\u00e9cran Premier panel de d\u00e9tail Nous allons cr\u00e9er un premier panel, pour afficher et \u00e9diter les caract\u00e9ristiques principales de notre movie . // app/views/movies/movie-detail/movie-characteristics.jsx // Libs import React , { PropTypes } from react ; // Components import { Panel } from focus-components/components ; export const MovieCharacteristics = React . createClass ({ render () { const { id } = this . props ; return ( Panel title = view.movie.detail.characteristics div { `panel de caract\u00e9ristiques du film ${ id } ` } /div /Panel ); } }); MovieCharacteristics . propTypes = { id : PropTypes . number . isRequired }; On instancie le composant dans la page principale : // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; +++ // Components +++ import { MovieCharacteristics } from ./movie-characteristics ; export const MovieDetailPage = React.createClass({ render() { const { id } = this.props; --- return div {`Page de d\u00e9tail du movie ${id}`} /div ; +++ return MovieCharacteristics id={id} / ; } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired }; Notre premier panel est maintenant pr\u00eat \u00e0 recevoir les donn\u00e9es depuis le store applicatif, et \u00e0 faire les appels serveurs permettant le chargement de l'entit\u00e9 dans les store. Chargement de l'entit\u00e9 Le chargement de l'entit\u00e9 passe par les stores applicatif, en suivant l'architecture flux . Il est donc n\u00e9cessaire de lancer l'action qui va effectuer le chargement serveur de l'entit\u00e9, et de s'abonner aux changements du store de l'entit\u00e9 afin de b\u00e9n\u00e9ficier des donn\u00e9es retourn\u00e9es par le serveur. Appelons le load au chargement de la page de d\u00e9tail afin de disposer des donn\u00e9es dans le store et donc dans les vues : // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; +++ // Actions +++ import { movieActions } from ../../../actions/movies ; export const MovieDetailPage = React.createClass({ +++ componentDidMount() { +++ movieActions.movieCharacteristics.load(); +++ }, render() { const { id } = this.props; return MovieCharacteristics id={id} / ; } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired }; Affichage de l'entit\u00e9 Maintenant que l'entit\u00e9 est charg\u00e9e en m\u00e9moire au montage de la page de d\u00e9tail, il est possible de l'afficher dans le panel MovieCharacteristics . Pour cela, nous allons utiliser le formMixin dans le panel. Il va nous faire b\u00e9n\u00e9ficier de l'ensemble des fonctionnalit\u00e9s du form focus, \u00e0 savoir : l'abonnement aux stores, le chargement des d\u00e9finitions avec domaines associ\u00e9s, les helpers de field, et le branchement aux actions de l'entit\u00e9 load et save . // app/views/movies/movie-detail/movie-characteristics.jsx // Libs import React, { PropTypes } from react ; +++ import { mixin as formMixin } from focus-components/mixin/form ; // Actions Stores import { movieActions } from ../../../actions/movies ; +++ import { movieDetailStore } from ../../../stores/movies ; // Components import { Panel } from focus-components/components ; export const MovieCharacteristics = React.createClass({ +++ // Ajout du form mixin +++ mixins: [formMixin], +++ // D\u00e9finition de notre entit\u00e9 +++ definitionPath: movie , +++ // Abonnement au store +++ stores: [{ store: movieDetailStore, properties: [ movieCharacteristics ] }], +++ // Donne les actions au form +++ action: movieActions.movieCharacteristics, --- render() { --- const { id } = this.props; +++ // render() est d\u00e9j\u00e0 d\u00e9fini par le formMixin +++ renderContent() { return ( --- Panel title= view.movie.detail.characteristics +++ Panel +++ actions={this._renderActions} +++ title= views.movie.detail.characteristics +++ --- div {`panel de caract\u00e9ristiques du film ${id}`} /div +++ {/* Les fieldFor sont des fonctions helper */} +++ {/* pour afficher et \u00e9diter un champ avec label} */} +++ {this.fieldFor( title )} +++ {this.fieldFor( originalTitle )} +++ {this.fieldFor( keywords )} +++ {this.fieldFor( runtime )} +++ {this.fieldFor( movieType )} +++ {this.fieldFor( productionYear )} /Panel ); } }); MovieCharacteristics.propTypes = { id: PropTypes.number.isRequired }; Il est important d'ajouter une prop depuis le parent vers MovieCharacteristics afin de lui signaler de ne pas effectuer le load \u00e0 son chargement, le composant parent le fait d\u00e9j\u00e0 dans son componentDidMount . Par d\u00e9faut, le formMixin se chargerait de le faire en appelant : this.action.load(this.props.id) . Faire le chargement dans le parent permet de s'assurer qu'il n'est fait qu'une fois pour l'ensemble des enfants. // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; // Actions import { movieActions } from ../../../actions/movies ; // Components import { MovieCharacteristics } from ./movie-characterics ; export const MovieDetailPage = React.createClass({ componentDidMount() { movieActions.movieCharacteristics.load(); }, render() { const { id } = this.props; --- return MovieCharacteristics id={id} / ; +++ return MovieCharacteristics id={id} hasLoad={false} / ; } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired }; Ajout second panel Nous allons ajouter un panel propre au synopsis du movie, afin de s\u00e9parer l'information et de rendre plus limpide la lecture de la page de d\u00e9tail. Le synopsis est un attribut de notre entit\u00e9, on b\u00e9n\u00e9ficie donc d\u00e9j\u00e0 de l'information dans le noeud movieCharacteristics du movieDetailStore . // app/views/movies/movie-detail/movie-synopsis.jsx // Libs import React , { PropTypes } from react ; import { mixin as formMixin } from focus-components/mixin/form ; // Actions Stores import { movieActions } from ../../../actions/movies ; import { movieDetailStore } from ../../../stores/movies ; // Components import { Panel } from focus-components/components ; export const MovieSynopsis = React . createClass ({ mixins : [ formMixin ], definitionPath : movie , stores : [{ store : movieDetailStore , properties : [ movieCharacteristics ] }], action : movieActions . movieCharacteristics , renderContent () { return ( Panel actions = { this . _renderActions } title = views.movie.detail.synopsis { this . fieldFor ( synopsis )} /Panel ); } }); MovieSynopsis . propTypes = { id : PropTypes . number . isRequired }; // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; // Actions import { movieActions } from ../../../actions/movies ; // Components import { MovieCharacteristics } from ./movie-characterics ; +++ import { MovieSynopsis } from ./movie-synopsis ; export const MovieDetailPage = React.createClass({ componentDidMount() { movieActions.movieCharacteristics.load(); }, render() { const { id } = this.props; return ( MovieCharacteristics id={id} hasLoad={false} / ; +++ MovieSynopsis id={id} hasLoad={false} / ; / ); } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired }; Ajout navigation rapide La navigation rapide est rapidemment mise en place. En effet, il s'agit d'un simple wrapper ScrollspyContainer autour de nos panels, qui va de lui-m\u00eame lister les panels et mettre en place la navigation. // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; // Actions import { movieActions } from ../../../actions/movies ; // Components +++ import ScrollspyContainer from focus-components/components/scrollspy-container ; import { MovieCharacteristics } from ./movie-characterics ; import { MovieSynopsis } from ./movie-synopsis ; export const MovieDetailPage = React.createClass({ componentDidMount() { movieActions.movieCharacteristics.load(); }, render() { const { id } = this.props; return ( --- +++ ScrollspyContainer MovieCharacteristics id={id} hasLoad={false} / ; MovieSynopsis id={id} hasLoad={false} / ; --- / +++ /ScrollspyContainer ); } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired }; Ajout du header Pour finaliser notre page de d\u00e9tail, nous allons ajouter des \u00e9l\u00e9ments dans le header (ou Cartridge). Le header a deux modes de fonctionnement : d\u00e9pli\u00e9 et repli\u00e9. Il faut donc lui fournir un composant pour chaque mode. Le store \u00e9tant d\u00e9j\u00e0 peupl\u00e9 par le composant de la page de d\u00e9tail, on peut donc simplement utiliser le formMixin pour s'abonner au store et afficher les champs qui nous int\u00e9ressent. // app/views/movies/movie-detail/header-expanded.jsx // Libs import React from react ; import { mixin as formMixin } from focus-components/mixin/form ; // Actions Stores import { movieDetailStore } from ../../../stores/movies ; // Components import Poster from ../components/poster ; export const MovieHeaderExpanded = React . createClass ({ displayName : MovieHeaderExpanded , mixins : [ formMixin ], definitionPath : movie , stores : [{ store : movieDetailStore , properties : [ movieCharacteristics ] }], renderContent () { const { poster , title } = this . state ; return ( div { poster Poster poster = { poster } title = { title } / } h3 { this . textFor ( title )} /h3 h5 { this . textFor ( movieType )} /h5 h6 { this . textFor ( productionYear )} /h6 div { this . textFor ( shortSynopsis )} /div /div ); } }); Le composant de header repli\u00e9 est similaire, avec quelques informations en moins pour occuper moins de place. // app/views/movies/movie-detail/header-collapsed.jsx // Libs import React from react ; import { mixin as formMixin } from focus-components/mixin/form ; // Actions Stores import { movieDetailStore } from ../../../stores/movies ; export const MovieHeaderCollapsed = React . createClass ({ displayName : MovieHeaderCollapsed , mixins : [ formMixin ], definitionPath : movie , stores : [{ store : movieDetailStore , properties : [ movieCharacteristics ] }], renderContent () { return ( div h3 { this . textFor ( title )} /h3 h6 { this . textFor ( productionYear )} /h6 /div ); } }); Nos composants de header sont d\u00e9finis, mais ne sont pas inject\u00e9s dans le header. Pour ce faire, on peut utiliser le cartridgeBehaviour , qui va permettre d'indiquer \u00e0 la page quels composants afficher dans le header, ainsi que les actions globales disponibles en tant que boutons dans le header. Modifions la page parente afin de lui donner le cartridgeBehaviour et d'envoyer les composants dans le header. // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; +++ import { cartridgeBehaviour } from focus-components/page/mixin ; // Actions import { movieActions } from ../../../actions/movies ; // Components import ScrollspyContainer from focus-components/components/scrollspy-container ; +++ import BackButton from focus-components/components/button-back/ ; import { MovieCharacteristics } from ./movie-characterics ; import { MovieSynopsis } from ./movie-synopsis ; +++ import { MovieHeaderCollapsed } from ./header-collapsed ; +++ import { MovieHeaderExpanded } from ./header-expanded ; export const MovieDetailPage = React.createClass({ componentDidMount() { movieActions.movieCharacteristics.load(); }, +++ mixins: [cartridgeBehaviour], +++ cartridgeConfiguration() { +++ const props = { hasLoad: false, hasForm: false }; // props qui seront donn\u00e9es aux composants du header +++ return { +++ barLeft: { component: BackButton }, // On ajoute le bouton Back en haut \u00e0 gauche de la page +++ cartridge: { component: MovieHeaderExpanded, props }, +++ summary: { component: MovieHeaderCollapsed, props }, +++ actions: { +++ primary: [ +++ { +++ // action d exemple +++ label: Imprimer , +++ icon: print , +++ action: () = { +++ alert( todo print ); +++ } +++ } +++ ], +++ secondary: [] +++ } +++ }; +++ } render() { const { id } = this.props; return ( ScrollspyContainer MovieCharacteristics id={id} hasLoad={false} / ; MovieSynopsis id={id} hasLoad={false} / ; /ScrollspyContainer ); } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired }; Epilogue","title":"Ecran de d\u00e9tail"},{"location":"tutorials/detail-page/#implementer-une-page-de-detail","text":"","title":"Impl\u00e9menter une page de d\u00e9tail"},{"location":"tutorials/detail-page/#objectifs","text":"L'objectif de cet exercise et de pouvoir afficher une page de d\u00e9tail d'un film. Elle est constitu\u00e9e : d'un header ( Cartridge ) d'une zone de navigation rapide ( Scrollspy ) d'un ou plusieurs blocks de d\u00e9tail ( Panel ) Une page de d\u00e9tail ressemble \u00e0 \u00e7a :","title":"Objectifs"},{"location":"tutorials/detail-page/#concepts-focus-manipules","text":"","title":"Concepts focus manipul\u00e9s"},{"location":"tutorials/detail-page/#le-corestore","text":"Focus propose un store simple CoreStore qui permet de stocker n-noeuds par store. L'id\u00e9e est que chaque store couvre un th\u00e8me fonctionnel de l'application. Par exemple, un store movieStore qui aura les noeuds : resume , characteristics , actors . Chaque noeud aura plusieurs propri\u00e9t\u00e9s associ\u00e9s : value , status , error . Warning Le CoreStore pour savoir s'il accepte la payload d'une action se base uniquement sur le nom du noeud. Si plusieurs stores ont un noeud avec un nom identique, alors il n'y a pas moyen de les diff\u00e9rencier.","title":"Le CoreStore"},{"location":"tutorials/detail-page/#le-actionbuilder","text":"Le ActionBuilder va permettre de cr\u00e9er simplement une action qui va \u00e9changer avec le server pour charger ou sauvegarder des donn\u00e9es. Lors de l'ex\u00e9cution d'une action, les op\u00e9rations suivantes sont effectu\u00e9es : Modifie le statut du noeud avec la valeur de preLoading (par d\u00e9faut: loading ) et passe isLoading \u00e0 vrai Si shouldDumpStoreOnActionCall est \u00e0 vrai, alors vide la valeur du noeud Appel le service configur\u00e9 et lui donne la payload Si on a configur\u00e9 un postService , on lui donne le retour du service pour transformation Dispatch le resultat du serveur dans le store, met le statut du noeud \u00e0 status et isLoading \u00e0 faux En cas de retour HTTP avec un code d'erreur, on dispatch dans le champ error du noeud Exemple de configuration d'un builder : const action : payload = Promise void = actionBuilder ({ // Noeud cibl\u00e9 node : movieCharacteristics , // Statut pendant le chargement/sauvegarde preLoading : loading , // Service \u00e0 appeler service : movieServices . loadMovieCharacteristics , // Si on vide le noeud pendant le chargement shouldDumpStoreOnActionCall : true , // Transformation du retour server postService : identity , // Le statut du noeud \u00e0 la fin de l appel status : loaded });","title":"Le ActionBuilder"},{"location":"tutorials/detail-page/#le-formmixin","text":"// TODO - d\u00e9crire le formMixin","title":"Le FormMixin"},{"location":"tutorials/detail-page/#creation-de-la-page","text":"Commen\u00e7ons par cr\u00e9er un dossier pour l'ensemble des composants de cette page de d\u00e9tail, dans notre dossier de vues: views . La mani\u00e8re dont vous organisez votre dossier de vues vous incombe, cependant une bonne pratique est de regrouper les vues par module puis par \u00e9cran. Dans notre cas, nous cr\u00e9ons le dossier : views/movies/movie-detail . Cr\u00e9ons notre composant parent : // app/views/movies/movie-detail/index.jsx // Libs import React , { PropTypes } from react ; export const MovieDetailPage = React . createClass ({ render () { const { id } = this . props ; return div { `Page de d\u00e9tail du movie ${ id } ` } /div ; } }); MovieDetailPage . propTypes = { id : PropTypes . number . isRequired }; Notre page de d\u00e9tail est pour l'instant tr\u00e8s simple, elle n'a qu'une prop , id , qui lui sera fournie par le routeur lorsque l'on navigue vers l'URI /#movies/{id} . Il faut donc cr\u00e9er un nouveau fichier pour les routes de movies : // app/routes/movie-routes.jsx // Libs import React from react ; // Components import { MovieDetailPage } from ../views/movies/movie-detail ; export const movieRoutes = [ { path : movies/:id , component : ({ params }) = MovieDetailPage id = { params . id } / } ]; Puis l'enregistrer aupr\u00e8s du router : // app/routes/index.js // Components import AppLayout from ../components/app-layout ; // Routes import { homeRoutes } from ./home-routes ; +++ import { movieRoutes } from ./movie-routes ; export default { path: `${__BASE_URL__}`, component: AppLayout, indexRoute: { onEnter: ({ params }, replace) = replace(`${__BASE_URL__}home`) }, --- childRoutes: [...homeRoutes] +++ childRoutes: [...homeRoutes, ...movieRoutes] };","title":"Cr\u00e9ation de la page"},{"location":"tutorials/detail-page/#les-pre-requis-pour-lecran","text":"","title":"Les pr\u00e9-requis pour l'\u00e9cran"},{"location":"tutorials/detail-page/#creation-du-store","text":"Dans le dossier app/stores de votre application cr\u00e9er un fichier movie-detail.js . // app/stores/movie-detail.js // Libs import { CoreStore } from focus-core/store ; // On cr\u00e9er une instance de ce store export const movieDetailStore = new CoreStore ({ movieCharacteristics : movieCharacteristics }); movieDetailStore . name = movieDetailStore ; Note Nous lui donnons un nom afin d'aider pour les messages de debug. Ce n'est pas obligatoire mais c'est mieux.","title":"Cr\u00e9ation du store"},{"location":"tutorials/detail-page/#creation-des-apis","text":"Notre entit\u00e9 movie dispose de deux APIs de manipulation, un load et et un save . Il est necessaire de cr\u00e9er le fichier config/server/movies.js qui contient les URIs expos\u00e9es par l'API. Le mieux pour cela est d'utiliser le paquet focus-service-generator (il est configur\u00e9 avec le starter kit) Ex\u00e9cutez : npm run generate Cela va g\u00e9n\u00e9rer un fichier de la forme suivante : // app/config/server/generated/movies.js import apiDriverBuilder from ../../../utilities/api-driver ; // Movies export default apiDriverBuilder ({ getMovie : { url : __API_ROOT__ + /api/movie/${id} , method : GET }, updateMovie : { url : __API_ROOT__ + /api/movie/${id} , method : PUT } // [...] }); Appelons le load au chargement de la page de d\u00e9tail afin de disposer des donn\u00e9es dans le store et donc dans les vues : Note La signature des m\u00e9thodes API sont de la forme : (uriParam, bodyParam, misc)","title":"Cr\u00e9ation des APIs"},{"location":"tutorials/detail-page/#creation-des-services","text":"Dans le fichier app/services/movies.js on va ajouter une m\u00e9thode pour charger et sauvegarder un film : // app/services/movies.js // Apis import moviesApi from ../config/server/generated/movies ; export const movieServices = { loadMovieCharacteristics ( id ) { return moviesApi . getMovie ({ id }); }, updateMovieCharacteristics ( movie ) { const { id } = movie ; return moviesApi . updateMovie ({ id }, movie ); } };","title":"Cr\u00e9ation des services"},{"location":"tutorials/detail-page/#creation-des-actions","text":"Cr\u00e9er un fichier pour les actions li\u00e9es \u00e0 votre entit\u00e9 // app/actions/movies.js // Libs import actionBuilder from focus-core/application/action-builder ; // Services import { movieServices } from ../services/movies ; export const movieActions = { movieCharacteristics : { load : actionBuilder ({ node : movieCharacteristics , service : movieServices . loadMovieCharacteristics , shouldDumpStoreOnActionCall : true , status : loaded }), save : actionBuilder ({ node : movieCharacteristics , service : movieServices . updateMovieCharacteristics , shouldDumpStoreOnActionCall : false , status : saved }) } };","title":"Cr\u00e9ation des actions"},{"location":"tutorials/detail-page/#les-composants-de-lecran","text":"","title":"Les composants de l'\u00e9cran"},{"location":"tutorials/detail-page/#premier-panel-de-detail","text":"Nous allons cr\u00e9er un premier panel, pour afficher et \u00e9diter les caract\u00e9ristiques principales de notre movie . // app/views/movies/movie-detail/movie-characteristics.jsx // Libs import React , { PropTypes } from react ; // Components import { Panel } from focus-components/components ; export const MovieCharacteristics = React . createClass ({ render () { const { id } = this . props ; return ( Panel title = view.movie.detail.characteristics div { `panel de caract\u00e9ristiques du film ${ id } ` } /div /Panel ); } }); MovieCharacteristics . propTypes = { id : PropTypes . number . isRequired }; On instancie le composant dans la page principale : // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; +++ // Components +++ import { MovieCharacteristics } from ./movie-characteristics ; export const MovieDetailPage = React.createClass({ render() { const { id } = this.props; --- return div {`Page de d\u00e9tail du movie ${id}`} /div ; +++ return MovieCharacteristics id={id} / ; } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired }; Notre premier panel est maintenant pr\u00eat \u00e0 recevoir les donn\u00e9es depuis le store applicatif, et \u00e0 faire les appels serveurs permettant le chargement de l'entit\u00e9 dans les store.","title":"Premier panel de d\u00e9tail"},{"location":"tutorials/detail-page/#chargement-de-lentite","text":"Le chargement de l'entit\u00e9 passe par les stores applicatif, en suivant l'architecture flux . Il est donc n\u00e9cessaire de lancer l'action qui va effectuer le chargement serveur de l'entit\u00e9, et de s'abonner aux changements du store de l'entit\u00e9 afin de b\u00e9n\u00e9ficier des donn\u00e9es retourn\u00e9es par le serveur. Appelons le load au chargement de la page de d\u00e9tail afin de disposer des donn\u00e9es dans le store et donc dans les vues : // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; +++ // Actions +++ import { movieActions } from ../../../actions/movies ; export const MovieDetailPage = React.createClass({ +++ componentDidMount() { +++ movieActions.movieCharacteristics.load(); +++ }, render() { const { id } = this.props; return MovieCharacteristics id={id} / ; } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired };","title":"Chargement de l'entit\u00e9"},{"location":"tutorials/detail-page/#affichage-de-lentite","text":"Maintenant que l'entit\u00e9 est charg\u00e9e en m\u00e9moire au montage de la page de d\u00e9tail, il est possible de l'afficher dans le panel MovieCharacteristics . Pour cela, nous allons utiliser le formMixin dans le panel. Il va nous faire b\u00e9n\u00e9ficier de l'ensemble des fonctionnalit\u00e9s du form focus, \u00e0 savoir : l'abonnement aux stores, le chargement des d\u00e9finitions avec domaines associ\u00e9s, les helpers de field, et le branchement aux actions de l'entit\u00e9 load et save . // app/views/movies/movie-detail/movie-characteristics.jsx // Libs import React, { PropTypes } from react ; +++ import { mixin as formMixin } from focus-components/mixin/form ; // Actions Stores import { movieActions } from ../../../actions/movies ; +++ import { movieDetailStore } from ../../../stores/movies ; // Components import { Panel } from focus-components/components ; export const MovieCharacteristics = React.createClass({ +++ // Ajout du form mixin +++ mixins: [formMixin], +++ // D\u00e9finition de notre entit\u00e9 +++ definitionPath: movie , +++ // Abonnement au store +++ stores: [{ store: movieDetailStore, properties: [ movieCharacteristics ] }], +++ // Donne les actions au form +++ action: movieActions.movieCharacteristics, --- render() { --- const { id } = this.props; +++ // render() est d\u00e9j\u00e0 d\u00e9fini par le formMixin +++ renderContent() { return ( --- Panel title= view.movie.detail.characteristics +++ Panel +++ actions={this._renderActions} +++ title= views.movie.detail.characteristics +++ --- div {`panel de caract\u00e9ristiques du film ${id}`} /div +++ {/* Les fieldFor sont des fonctions helper */} +++ {/* pour afficher et \u00e9diter un champ avec label} */} +++ {this.fieldFor( title )} +++ {this.fieldFor( originalTitle )} +++ {this.fieldFor( keywords )} +++ {this.fieldFor( runtime )} +++ {this.fieldFor( movieType )} +++ {this.fieldFor( productionYear )} /Panel ); } }); MovieCharacteristics.propTypes = { id: PropTypes.number.isRequired }; Il est important d'ajouter une prop depuis le parent vers MovieCharacteristics afin de lui signaler de ne pas effectuer le load \u00e0 son chargement, le composant parent le fait d\u00e9j\u00e0 dans son componentDidMount . Par d\u00e9faut, le formMixin se chargerait de le faire en appelant : this.action.load(this.props.id) . Faire le chargement dans le parent permet de s'assurer qu'il n'est fait qu'une fois pour l'ensemble des enfants. // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; // Actions import { movieActions } from ../../../actions/movies ; // Components import { MovieCharacteristics } from ./movie-characterics ; export const MovieDetailPage = React.createClass({ componentDidMount() { movieActions.movieCharacteristics.load(); }, render() { const { id } = this.props; --- return MovieCharacteristics id={id} / ; +++ return MovieCharacteristics id={id} hasLoad={false} / ; } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired };","title":"Affichage de l'entit\u00e9"},{"location":"tutorials/detail-page/#ajout-second-panel","text":"Nous allons ajouter un panel propre au synopsis du movie, afin de s\u00e9parer l'information et de rendre plus limpide la lecture de la page de d\u00e9tail. Le synopsis est un attribut de notre entit\u00e9, on b\u00e9n\u00e9ficie donc d\u00e9j\u00e0 de l'information dans le noeud movieCharacteristics du movieDetailStore . // app/views/movies/movie-detail/movie-synopsis.jsx // Libs import React , { PropTypes } from react ; import { mixin as formMixin } from focus-components/mixin/form ; // Actions Stores import { movieActions } from ../../../actions/movies ; import { movieDetailStore } from ../../../stores/movies ; // Components import { Panel } from focus-components/components ; export const MovieSynopsis = React . createClass ({ mixins : [ formMixin ], definitionPath : movie , stores : [{ store : movieDetailStore , properties : [ movieCharacteristics ] }], action : movieActions . movieCharacteristics , renderContent () { return ( Panel actions = { this . _renderActions } title = views.movie.detail.synopsis { this . fieldFor ( synopsis )} /Panel ); } }); MovieSynopsis . propTypes = { id : PropTypes . number . isRequired }; // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; // Actions import { movieActions } from ../../../actions/movies ; // Components import { MovieCharacteristics } from ./movie-characterics ; +++ import { MovieSynopsis } from ./movie-synopsis ; export const MovieDetailPage = React.createClass({ componentDidMount() { movieActions.movieCharacteristics.load(); }, render() { const { id } = this.props; return ( MovieCharacteristics id={id} hasLoad={false} / ; +++ MovieSynopsis id={id} hasLoad={false} / ; / ); } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired };","title":"Ajout second panel"},{"location":"tutorials/detail-page/#ajout-navigation-rapide","text":"La navigation rapide est rapidemment mise en place. En effet, il s'agit d'un simple wrapper ScrollspyContainer autour de nos panels, qui va de lui-m\u00eame lister les panels et mettre en place la navigation. // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; // Actions import { movieActions } from ../../../actions/movies ; // Components +++ import ScrollspyContainer from focus-components/components/scrollspy-container ; import { MovieCharacteristics } from ./movie-characterics ; import { MovieSynopsis } from ./movie-synopsis ; export const MovieDetailPage = React.createClass({ componentDidMount() { movieActions.movieCharacteristics.load(); }, render() { const { id } = this.props; return ( --- +++ ScrollspyContainer MovieCharacteristics id={id} hasLoad={false} / ; MovieSynopsis id={id} hasLoad={false} / ; --- / +++ /ScrollspyContainer ); } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired };","title":"Ajout navigation rapide"},{"location":"tutorials/detail-page/#ajout-du-header","text":"Pour finaliser notre page de d\u00e9tail, nous allons ajouter des \u00e9l\u00e9ments dans le header (ou Cartridge). Le header a deux modes de fonctionnement : d\u00e9pli\u00e9 et repli\u00e9. Il faut donc lui fournir un composant pour chaque mode. Le store \u00e9tant d\u00e9j\u00e0 peupl\u00e9 par le composant de la page de d\u00e9tail, on peut donc simplement utiliser le formMixin pour s'abonner au store et afficher les champs qui nous int\u00e9ressent. // app/views/movies/movie-detail/header-expanded.jsx // Libs import React from react ; import { mixin as formMixin } from focus-components/mixin/form ; // Actions Stores import { movieDetailStore } from ../../../stores/movies ; // Components import Poster from ../components/poster ; export const MovieHeaderExpanded = React . createClass ({ displayName : MovieHeaderExpanded , mixins : [ formMixin ], definitionPath : movie , stores : [{ store : movieDetailStore , properties : [ movieCharacteristics ] }], renderContent () { const { poster , title } = this . state ; return ( div { poster Poster poster = { poster } title = { title } / } h3 { this . textFor ( title )} /h3 h5 { this . textFor ( movieType )} /h5 h6 { this . textFor ( productionYear )} /h6 div { this . textFor ( shortSynopsis )} /div /div ); } }); Le composant de header repli\u00e9 est similaire, avec quelques informations en moins pour occuper moins de place. // app/views/movies/movie-detail/header-collapsed.jsx // Libs import React from react ; import { mixin as formMixin } from focus-components/mixin/form ; // Actions Stores import { movieDetailStore } from ../../../stores/movies ; export const MovieHeaderCollapsed = React . createClass ({ displayName : MovieHeaderCollapsed , mixins : [ formMixin ], definitionPath : movie , stores : [{ store : movieDetailStore , properties : [ movieCharacteristics ] }], renderContent () { return ( div h3 { this . textFor ( title )} /h3 h6 { this . textFor ( productionYear )} /h6 /div ); } }); Nos composants de header sont d\u00e9finis, mais ne sont pas inject\u00e9s dans le header. Pour ce faire, on peut utiliser le cartridgeBehaviour , qui va permettre d'indiquer \u00e0 la page quels composants afficher dans le header, ainsi que les actions globales disponibles en tant que boutons dans le header. Modifions la page parente afin de lui donner le cartridgeBehaviour et d'envoyer les composants dans le header. // app/views/movies/movie-detail/index.jsx // Libs import React, { PropTypes } from react ; +++ import { cartridgeBehaviour } from focus-components/page/mixin ; // Actions import { movieActions } from ../../../actions/movies ; // Components import ScrollspyContainer from focus-components/components/scrollspy-container ; +++ import BackButton from focus-components/components/button-back/ ; import { MovieCharacteristics } from ./movie-characterics ; import { MovieSynopsis } from ./movie-synopsis ; +++ import { MovieHeaderCollapsed } from ./header-collapsed ; +++ import { MovieHeaderExpanded } from ./header-expanded ; export const MovieDetailPage = React.createClass({ componentDidMount() { movieActions.movieCharacteristics.load(); }, +++ mixins: [cartridgeBehaviour], +++ cartridgeConfiguration() { +++ const props = { hasLoad: false, hasForm: false }; // props qui seront donn\u00e9es aux composants du header +++ return { +++ barLeft: { component: BackButton }, // On ajoute le bouton Back en haut \u00e0 gauche de la page +++ cartridge: { component: MovieHeaderExpanded, props }, +++ summary: { component: MovieHeaderCollapsed, props }, +++ actions: { +++ primary: [ +++ { +++ // action d exemple +++ label: Imprimer , +++ icon: print , +++ action: () = { +++ alert( todo print ); +++ } +++ } +++ ], +++ secondary: [] +++ } +++ }; +++ } render() { const { id } = this.props; return ( ScrollspyContainer MovieCharacteristics id={id} hasLoad={false} / ; MovieSynopsis id={id} hasLoad={false} / ; /ScrollspyContainer ); } }); MovieDetailPage.propTypes = { id: PropTypes.number.isRequired };","title":"Ajout du header"},{"location":"tutorials/detail-page/#epilogue","text":"","title":"Epilogue"},{"location":"tutorials/liste-page/","text":"Impl\u00e9menter une liste administrable Objectifs L'objectif de cet exercice est de pouvoir afficher une liste potentiellement tr\u00e8s longue. Il sera possible de : Editer ligne par ligne dans une popin qui appara\u00eetra depuis la droite de l'\u00e9cran, Rafraichir les \u00e9l\u00e9ments de la liste en sortie d'\u00e9dition d'un \u00e9l\u00e9ment, Mettre en place un filtre afin d'affiner les \u00e9l\u00e9ments affich\u00e9s dans la liste. L'API utilis\u00e9e afin de communiquer avec le serveur est cal\u00e9e sur celle du moteur de recherche. Normalement vous devriez avoir une page qui ressemble \u00e0 \u00e7a \u00e0 la fin: Le mode liste : Le mode \u00e9dition d'une ligne : Concepts focus manipul\u00e9s Le ListStore Focus propose un store de liste accessible dans focus-core/store/list . Le store de liste aura les noeuds suivants : criteria : Le crit\u00e8re \u00e9ventuel de recherche qui doit \u00eatre un objet structur\u00e9, sortBy : Par quel \u00e9lement la liste est tri\u00e9e, sortAsc : Le caract\u00e8re ascendant ou non pour le tri, dataList : Les \u00e9lements de la liste (une partie au moins s'il y a pagination), totalCount : Le nombre total d'\u00e9l\u00e9ments de la liste (utile pour r\u00e9aliser la pagination). Warning Attention il est n\u00e9cessaire de fournir au moment de l'instanciation de ce store une cl\u00e9 unique qui permettra de distinguer un store de liste d'un autre, tous les stores ayant les m\u00eame noeuds Le ListActionBuilder Le builder permet de cr\u00e9er deux choses : Une action qui sera appell\u00e9e par le composant de liste a chaque fois qu'un changement est op\u00e9r\u00e9 dans le store de liste Une fonction qui permet de dispatcher de nouveaux \u00e9lements dans le store Les Composants graphiques Le composant qui est responsable de g\u00e9rer l'affichage de la liste focus-components/page/list le composant d'affichage d'une liste dans focus qui est focus-components/list/selection Il est important de comprendre \u00e0 ce niveau que parmi tous les composants que vous allez cr\u00e9er, seul le composant principal de liste effectuera des requ\u00eates \u00e0 l'API afin de r\u00e9cup\u00e9rer les donn\u00e9es. Les autres composants auront juste pour t\u00e2che de mettre \u00e0 jour le store de liste en fonction des cas d'usages. Cr\u00e9ation de la page Commen\u00e7ons par cr\u00e9er un dossier pour l'ensemble des composants de cette page de liste, dans notre dossier de vues: views . La mani\u00e8re dont vous organisez votre dossier de vues vous incombe, cependant une bonne pratique est de regrouper les vues par module puis par \u00e9cran. Dans notre cas, nous cr\u00e9ons le dossier : views/movies/movie-list . Cr\u00e9ons notre composant parent : // app/views/movies/movie-list/index.jsx // Libs import React from react ; export const MovieListPage = React . createClass ({ render () { return ( div Barre de recherche de films /div div Liste de films /div div Popin de preview d un film /div / ); } }); Notre page de d\u00e9tail est pour l'instant tr\u00e8s simple, elle est affich\u00e9e lorsque l'on navigue vers l'URI /#movies . Il faut donc cr\u00e9er un nouveau fichier pour les routes de movies : // app/routes/movie-routes.jsx // Libs import React from react ; // Components +++ import { MovieListPage } from ../views/movies/movie-list ; export const movieRoutes = [ +++ { +++ path: movies , +++ component: ({ params }) = MovieListPage / +++ }, // [...] ]; Puis l'enregistrer aupr\u00e8s du router : // app/routes/index.js // Components import AppLayout from ../components/app-layout ; // Routes import { homeRoutes } from ./home-routes ; +++ import { movieRoutes } from ./movie-routes ; export default { path: `${__BASE_URL__}`, component: AppLayout, indexRoute: { onEnter: ({ params }, replace) = replace(`${__BASE_URL__}home`) }, --- childRoutes: [...homeRoutes] +++ childRoutes: [...homeRoutes, ...movieRoutes] }; Les pr\u00e9-requis pour la liste Cr\u00e9ation du store Dans le dossier app/stores de votre application cr\u00e9er un fichier movie-list.js . // app/stores/movie-list.js // Libs import ListStore from focus-core/store/list ; // On cr\u00e9er une instance de ce store avec un identifiant unique export const movieListStore = new ListStore ({ identifier : movieList }); movieListStore . name = MovieListStore ; Note Nous lui donnons un nom afin d'aider pour les messages de debug. Ce n'est pas obligatoire mais c'est mieux. Cr\u00e9ation du service Dans le fichier app/services/movies.js on va ajouter une m\u00e9thode pour rechercher des films : // app/services/movies.js // Apis import moviesApi from ../config/server/generated/movies ; export const movieServices = { // [...] searchMovies ({ urlData , data }) { return movieApiDriver . searchMovies ( urlData , data ); } }; Un contrat \u00e0 respecter est obligatoire pour cette API. Les param\u00e8tres d'ent\u00e9e de l'API sont de la forme suivante : const { criteria } = data ; const { skip , top , sortBy , sortAsc } = urlData ; Les param\u00e8tres de sortie de l'API sont de la forme suivante : { dataList : [{ id : 1 , ...}, ...], totalCount : XXX } Si ce n'est pas le cas et que vous avez directement les data, n'oubliez pas que le type de retour de fetch est une promesse, et qui est donc par d\u00e9finition : chainable . Vous pouvez faire la chose suivante dans votre service pour normaliser les donn\u00e9es au format attendu par focus : return movieApiDriver . searchMovie ( urlData , data ) . then ( data = ({ dataList : data , totalCount : data . length })); Mais il est pr\u00e9f\u00e9rable que votre serveur vous retourne un objet d\u00e9j\u00e0 bien construit. Cr\u00e9ation de l'action Cr\u00e9er un fichier pour les actions li\u00e9es \u00e0 votre entit\u00e9 // app/actions/movies.js // Libs import listActionBuilder from focus-core/list/action-builder ; // Stores import { movieListStore } from ../stores/movie-list ; // Services import { movieServices } from ../services/movies ; export const movieActions = { // [...] searchMovies = listActionBuilder ({ service : movieServices . searchMovies , identifier : movieList , getListOptions : () = movieListStore . getValue () }); }; Le builder listActionBuilder va retourner un objet avec deux fonction : load : La fonction de load de la liste, updateProperties : La fonction pour mettre \u00e0 jour les \u00e9lements du store. On a maintentant tout ce qu'il nous faut afin de cr\u00e9er le composant. Les composants de l'\u00e9cran Cr\u00e9ation du composant de liste Commen\u00e7ons par cr\u00e9er le composant de liste. // app/views/movies/movie-list/movie-list.jsx // Libs import React , { PropTypes } from react ; // Stores import { movieListStore } from ../../../stores/movie-list ; // Actions import { movieActions } from ../../../actions/movies ; // Components import { component as List } from focus-components/page/list ; import { MovieLine } from ./movie-line ; const columns = { title : { label : movie.title }, productionYear : { label : movie.productionYear } }; export const MovieList = ({ onLineClick }) = { return ( List // L action qui charge la liste action = { movieActions . searchMovies } // Les colonnes \u00e0 afficher columns = { columns } // Dire \u00e0 la liste qu elle n est pas s\u00e9lectionnable isSelection = { false } // La ligne \u00e0 utliser dans la liste LineComponent = { MovieLine } // Le handler de click sur la ligne onLineClick = { onLineClick } // Le store sur lequel le composant doit s abonner. store = { movieListStore } / ); }; MovieList . propTypes = { onLineClick : PropTypes . func . isRequired }; Cr\u00e9ation du composant de ligne Nous allons maintenant cr\u00e9er le contenu de la ligne. Nous avons besoin d'aller chercher la d\u00e9finition de l'entit\u00e9 qui contient l'ensemble des m\u00e9tadonn\u00e9es associ\u00e9es \u00e0 chacun de champ de la ligne. // Libs import React from react ; // Components import { mixin as LineMixin } from focus-components/list/selection/line ; export const MovieLine = React . createClass ({ displayName : MovieLine , mixins : [ LineMixin ], definitionPath : movie , // D\u00e9finition de l entit\u00e9 renderLineContent ( data ) { return ( tr onClick = {() = this . props . onLineClick ( data . id )} td { this . textFor ( title )} /td td { this . textFor ( productionYear )} /td /tr ); } }); La ligne est maintenant cr\u00e9\u00e9e, la liste est fonctionnelle. On peut ajouter la liste nouvellement cr\u00e9\u00e9e \u00e0 la page : // app/views/movies/movie-list/index.jsx // Libs import React from react ; +++ // Components +++ import { MovieList } from ./movie-list ; export const MovieListPage = React.createClass({ render() { return ( div Barre de recherche de films /div --- div Liste de films /div +++ MovieList onLineClick={() = { /* RAF */ }} / div Popin de preview d un film /div ); } }); Cr\u00e9ation du filtre de recherche On va cr\u00e9er un filtre de recherche. La logique de ce composant est d'avoir un texte \u00e0 saisir et une action \u00e0 appeller lorsque ce texte est modifi\u00e9. Le composant va donc prendre en entr\u00e9e une props : onFilterChange . // app/views/movies/movie-list/movie-criteria.jsx // Libs import React , { PropTypes } from react ; import { debounce } from lodash ; import { translate } from focus-core/translation ; export const MovieCriteria = React . CreateClass ({ displayName : MovieCriteria , mixins : [ formMixin ], definitionPath : movie , getInitalState () { return { title : }; }, render () { const { filter , onFilterChange } = this . props ; return ( div data - demo = movie-criteria { this . fieldfor ( title , { value : filter , onChange : title = onFilterChange ( title ) })} /div ); } }); MovieCriteria . propTypes = { filter : PropType . string , onFilterChange : PropTypes . func . isRequired }; Nous devons maintenant ajouter ce composant dans le composant principal. Et ajouter une fonction qui permettra de dispatcher le query de recherche. Ajout dans le render : // app/views/movies/movie-list/index.jsx // Libs import React from react ; +++ // Store +++ import { movieListStore } from ../../../stores/movie-list ; +++ // Actions +++ import { movieActions } from ../../../actions/movies ; // Components import { MovieList } from ./movie-list ; import { MovieCriteria } from ./movie-criteria ; +++ function onFilterChange(title) { +++ moviesActions.searchMovies.updateProperties({ +++ criteria: { title } +++ }); +++ } export const MovieListPage = React.createClass({ render() { +++ const properties = movieListStore.getValue(); return ( --- div Barre de recherche de films /div +++ MovieCriteria +++ filter={properties.criteria.title} +++ onFilterChange={onFilterChange} +++ / MovieList onLineClick={() = { /* RAF */ }} / div Popin de preview d un film /div ); } }); Note Utiliser la fonction updateProperties d\u00e9clanche automatiquement une recherche Cr\u00e9ation de la popin d'\u00e9dition Ici pour simplifier nous ne mettrons pas le formulaire car la logique est strictement identique \u00e0 celle de cr\u00e9ation de l'\u00e9cran de d\u00e9tail. Voir page de d\u00e9tail // app/views/movies/movie-list/popin.jsx // Libs import React , { PropTypes } from react ; import { translate } from focus-core/translation ; // Components import Panel from focus-components/components/panel ; import { component as Popin } from focus-components/components/popin ; export function MoviePopin ({ id , isOpen , onPopinClose }) { return ( Popin open = { isOpen } onPopinClose = { onPopinClose } h4 { translate ( movie.popin.title )} /h4 div { `Popin d \u00e9dition pour le film ${ id } ` } /div { /* Affichage du formulaire de d\u00e9tail */ } /Popin ); } MoviePopin . propTypes = { id : PropTypes . number , isOpen : PropTypes . boolean . isRequired , onPopinClose : PropTypes . func . isRequired }; Cette poin doit maintenant \u00eatre ajout\u00e9e dans le composant principal de la liste . // app/views/movies/movie-list/index.jsx // Libs import React from react ; // Actions import { movieActions } from ../../../actions/movies ; // Components import { MovieList } from ./movie-list ; import { MovieCriteria } from ./movie-criteria ; +++ import { MoviePopin } from ./movie-popin ; function onFilterChange(title) { moviesActions.searchMovies.updateProperties({ criteria: { title } }); } export const MovieListPage = React.createClass({ +++ getInitialState() { +++ return { id: undefined }; +++ }, +++ onPopinClose() { +++ this.setState({ id: undefined }); +++ }, +++ openPopin(id) { +++ this.setState({ id }); +++ }, render() { return ( MovieCriteria onFilterChange={onFilterChange} / --- MovieList onLineClick={() = { /* RAF */ }} / +++ MovieList onLineClick={id = this.openPopin(id)} / --- div Popin de preview d un film /div +++ MoviePopin +++ id={this.state.id} +++ isOpen={this.state.id !== undefined} +++ onPopinClose={() = this.onPopinClose()} +++ / ); } }); Nous avons fait les modifications suivante : Ajout d'un state pour savoir l'identifiant du movie sur lequel on a cliqu\u00e9 Donn\u00e9 la m\u00e9thode openPopin au composant MovieList pour ouvrir la popin Donn\u00e9 la m\u00e9thode onPopinClose au composant MoviePopin pour fermer la popin Ici, le trick est d'utiliser la propri\u00e9t\u00e9 id pour savoir si la popin est ouverte ou ferm\u00e9e. Epilogue","title":"Ecran de liste"},{"location":"tutorials/liste-page/#implementer-une-liste-administrable","text":"","title":"Impl\u00e9menter une liste administrable"},{"location":"tutorials/liste-page/#objectifs","text":"L'objectif de cet exercice est de pouvoir afficher une liste potentiellement tr\u00e8s longue. Il sera possible de : Editer ligne par ligne dans une popin qui appara\u00eetra depuis la droite de l'\u00e9cran, Rafraichir les \u00e9l\u00e9ments de la liste en sortie d'\u00e9dition d'un \u00e9l\u00e9ment, Mettre en place un filtre afin d'affiner les \u00e9l\u00e9ments affich\u00e9s dans la liste. L'API utilis\u00e9e afin de communiquer avec le serveur est cal\u00e9e sur celle du moteur de recherche. Normalement vous devriez avoir une page qui ressemble \u00e0 \u00e7a \u00e0 la fin: Le mode liste : Le mode \u00e9dition d'une ligne :","title":"Objectifs"},{"location":"tutorials/liste-page/#concepts-focus-manipules","text":"","title":"Concepts focus manipul\u00e9s"},{"location":"tutorials/liste-page/#le-liststore","text":"Focus propose un store de liste accessible dans focus-core/store/list . Le store de liste aura les noeuds suivants : criteria : Le crit\u00e8re \u00e9ventuel de recherche qui doit \u00eatre un objet structur\u00e9, sortBy : Par quel \u00e9lement la liste est tri\u00e9e, sortAsc : Le caract\u00e8re ascendant ou non pour le tri, dataList : Les \u00e9lements de la liste (une partie au moins s'il y a pagination), totalCount : Le nombre total d'\u00e9l\u00e9ments de la liste (utile pour r\u00e9aliser la pagination). Warning Attention il est n\u00e9cessaire de fournir au moment de l'instanciation de ce store une cl\u00e9 unique qui permettra de distinguer un store de liste d'un autre, tous les stores ayant les m\u00eame noeuds","title":"Le ListStore"},{"location":"tutorials/liste-page/#le-listactionbuilder","text":"Le builder permet de cr\u00e9er deux choses : Une action qui sera appell\u00e9e par le composant de liste a chaque fois qu'un changement est op\u00e9r\u00e9 dans le store de liste Une fonction qui permet de dispatcher de nouveaux \u00e9lements dans le store","title":"Le ListActionBuilder"},{"location":"tutorials/liste-page/#les-composants-graphiques","text":"Le composant qui est responsable de g\u00e9rer l'affichage de la liste focus-components/page/list le composant d'affichage d'une liste dans focus qui est focus-components/list/selection Il est important de comprendre \u00e0 ce niveau que parmi tous les composants que vous allez cr\u00e9er, seul le composant principal de liste effectuera des requ\u00eates \u00e0 l'API afin de r\u00e9cup\u00e9rer les donn\u00e9es. Les autres composants auront juste pour t\u00e2che de mettre \u00e0 jour le store de liste en fonction des cas d'usages.","title":"Les Composants graphiques"},{"location":"tutorials/liste-page/#creation-de-la-page","text":"Commen\u00e7ons par cr\u00e9er un dossier pour l'ensemble des composants de cette page de liste, dans notre dossier de vues: views . La mani\u00e8re dont vous organisez votre dossier de vues vous incombe, cependant une bonne pratique est de regrouper les vues par module puis par \u00e9cran. Dans notre cas, nous cr\u00e9ons le dossier : views/movies/movie-list . Cr\u00e9ons notre composant parent : // app/views/movies/movie-list/index.jsx // Libs import React from react ; export const MovieListPage = React . createClass ({ render () { return ( div Barre de recherche de films /div div Liste de films /div div Popin de preview d un film /div / ); } }); Notre page de d\u00e9tail est pour l'instant tr\u00e8s simple, elle est affich\u00e9e lorsque l'on navigue vers l'URI /#movies . Il faut donc cr\u00e9er un nouveau fichier pour les routes de movies : // app/routes/movie-routes.jsx // Libs import React from react ; // Components +++ import { MovieListPage } from ../views/movies/movie-list ; export const movieRoutes = [ +++ { +++ path: movies , +++ component: ({ params }) = MovieListPage / +++ }, // [...] ]; Puis l'enregistrer aupr\u00e8s du router : // app/routes/index.js // Components import AppLayout from ../components/app-layout ; // Routes import { homeRoutes } from ./home-routes ; +++ import { movieRoutes } from ./movie-routes ; export default { path: `${__BASE_URL__}`, component: AppLayout, indexRoute: { onEnter: ({ params }, replace) = replace(`${__BASE_URL__}home`) }, --- childRoutes: [...homeRoutes] +++ childRoutes: [...homeRoutes, ...movieRoutes] };","title":"Cr\u00e9ation de la page"},{"location":"tutorials/liste-page/#les-pre-requis-pour-la-liste","text":"","title":"Les pr\u00e9-requis pour la liste"},{"location":"tutorials/liste-page/#creation-du-store","text":"Dans le dossier app/stores de votre application cr\u00e9er un fichier movie-list.js . // app/stores/movie-list.js // Libs import ListStore from focus-core/store/list ; // On cr\u00e9er une instance de ce store avec un identifiant unique export const movieListStore = new ListStore ({ identifier : movieList }); movieListStore . name = MovieListStore ; Note Nous lui donnons un nom afin d'aider pour les messages de debug. Ce n'est pas obligatoire mais c'est mieux.","title":"Cr\u00e9ation du store"},{"location":"tutorials/liste-page/#creation-du-service","text":"Dans le fichier app/services/movies.js on va ajouter une m\u00e9thode pour rechercher des films : // app/services/movies.js // Apis import moviesApi from ../config/server/generated/movies ; export const movieServices = { // [...] searchMovies ({ urlData , data }) { return movieApiDriver . searchMovies ( urlData , data ); } }; Un contrat \u00e0 respecter est obligatoire pour cette API. Les param\u00e8tres d'ent\u00e9e de l'API sont de la forme suivante : const { criteria } = data ; const { skip , top , sortBy , sortAsc } = urlData ; Les param\u00e8tres de sortie de l'API sont de la forme suivante : { dataList : [{ id : 1 , ...}, ...], totalCount : XXX } Si ce n'est pas le cas et que vous avez directement les data, n'oubliez pas que le type de retour de fetch est une promesse, et qui est donc par d\u00e9finition : chainable . Vous pouvez faire la chose suivante dans votre service pour normaliser les donn\u00e9es au format attendu par focus : return movieApiDriver . searchMovie ( urlData , data ) . then ( data = ({ dataList : data , totalCount : data . length })); Mais il est pr\u00e9f\u00e9rable que votre serveur vous retourne un objet d\u00e9j\u00e0 bien construit.","title":"Cr\u00e9ation du service"},{"location":"tutorials/liste-page/#creation-de-laction","text":"Cr\u00e9er un fichier pour les actions li\u00e9es \u00e0 votre entit\u00e9 // app/actions/movies.js // Libs import listActionBuilder from focus-core/list/action-builder ; // Stores import { movieListStore } from ../stores/movie-list ; // Services import { movieServices } from ../services/movies ; export const movieActions = { // [...] searchMovies = listActionBuilder ({ service : movieServices . searchMovies , identifier : movieList , getListOptions : () = movieListStore . getValue () }); }; Le builder listActionBuilder va retourner un objet avec deux fonction : load : La fonction de load de la liste, updateProperties : La fonction pour mettre \u00e0 jour les \u00e9lements du store. On a maintentant tout ce qu'il nous faut afin de cr\u00e9er le composant.","title":"Cr\u00e9ation de l'action"},{"location":"tutorials/liste-page/#les-composants-de-lecran","text":"","title":"Les composants de l'\u00e9cran"},{"location":"tutorials/liste-page/#creation-du-composant-de-liste","text":"Commen\u00e7ons par cr\u00e9er le composant de liste. // app/views/movies/movie-list/movie-list.jsx // Libs import React , { PropTypes } from react ; // Stores import { movieListStore } from ../../../stores/movie-list ; // Actions import { movieActions } from ../../../actions/movies ; // Components import { component as List } from focus-components/page/list ; import { MovieLine } from ./movie-line ; const columns = { title : { label : movie.title }, productionYear : { label : movie.productionYear } }; export const MovieList = ({ onLineClick }) = { return ( List // L action qui charge la liste action = { movieActions . searchMovies } // Les colonnes \u00e0 afficher columns = { columns } // Dire \u00e0 la liste qu elle n est pas s\u00e9lectionnable isSelection = { false } // La ligne \u00e0 utliser dans la liste LineComponent = { MovieLine } // Le handler de click sur la ligne onLineClick = { onLineClick } // Le store sur lequel le composant doit s abonner. store = { movieListStore } / ); }; MovieList . propTypes = { onLineClick : PropTypes . func . isRequired };","title":"Cr\u00e9ation du composant de liste"},{"location":"tutorials/liste-page/#creation-du-composant-de-ligne","text":"Nous allons maintenant cr\u00e9er le contenu de la ligne. Nous avons besoin d'aller chercher la d\u00e9finition de l'entit\u00e9 qui contient l'ensemble des m\u00e9tadonn\u00e9es associ\u00e9es \u00e0 chacun de champ de la ligne. // Libs import React from react ; // Components import { mixin as LineMixin } from focus-components/list/selection/line ; export const MovieLine = React . createClass ({ displayName : MovieLine , mixins : [ LineMixin ], definitionPath : movie , // D\u00e9finition de l entit\u00e9 renderLineContent ( data ) { return ( tr onClick = {() = this . props . onLineClick ( data . id )} td { this . textFor ( title )} /td td { this . textFor ( productionYear )} /td /tr ); } }); La ligne est maintenant cr\u00e9\u00e9e, la liste est fonctionnelle. On peut ajouter la liste nouvellement cr\u00e9\u00e9e \u00e0 la page : // app/views/movies/movie-list/index.jsx // Libs import React from react ; +++ // Components +++ import { MovieList } from ./movie-list ; export const MovieListPage = React.createClass({ render() { return ( div Barre de recherche de films /div --- div Liste de films /div +++ MovieList onLineClick={() = { /* RAF */ }} / div Popin de preview d un film /div ); } });","title":"Cr\u00e9ation du composant de ligne"},{"location":"tutorials/liste-page/#creation-du-filtre-de-recherche","text":"On va cr\u00e9er un filtre de recherche. La logique de ce composant est d'avoir un texte \u00e0 saisir et une action \u00e0 appeller lorsque ce texte est modifi\u00e9. Le composant va donc prendre en entr\u00e9e une props : onFilterChange . // app/views/movies/movie-list/movie-criteria.jsx // Libs import React , { PropTypes } from react ; import { debounce } from lodash ; import { translate } from focus-core/translation ; export const MovieCriteria = React . CreateClass ({ displayName : MovieCriteria , mixins : [ formMixin ], definitionPath : movie , getInitalState () { return { title : }; }, render () { const { filter , onFilterChange } = this . props ; return ( div data - demo = movie-criteria { this . fieldfor ( title , { value : filter , onChange : title = onFilterChange ( title ) })} /div ); } }); MovieCriteria . propTypes = { filter : PropType . string , onFilterChange : PropTypes . func . isRequired }; Nous devons maintenant ajouter ce composant dans le composant principal. Et ajouter une fonction qui permettra de dispatcher le query de recherche. Ajout dans le render : // app/views/movies/movie-list/index.jsx // Libs import React from react ; +++ // Store +++ import { movieListStore } from ../../../stores/movie-list ; +++ // Actions +++ import { movieActions } from ../../../actions/movies ; // Components import { MovieList } from ./movie-list ; import { MovieCriteria } from ./movie-criteria ; +++ function onFilterChange(title) { +++ moviesActions.searchMovies.updateProperties({ +++ criteria: { title } +++ }); +++ } export const MovieListPage = React.createClass({ render() { +++ const properties = movieListStore.getValue(); return ( --- div Barre de recherche de films /div +++ MovieCriteria +++ filter={properties.criteria.title} +++ onFilterChange={onFilterChange} +++ / MovieList onLineClick={() = { /* RAF */ }} / div Popin de preview d un film /div ); } }); Note Utiliser la fonction updateProperties d\u00e9clanche automatiquement une recherche","title":"Cr\u00e9ation du filtre de recherche"},{"location":"tutorials/liste-page/#creation-de-la-popin-dedition","text":"Ici pour simplifier nous ne mettrons pas le formulaire car la logique est strictement identique \u00e0 celle de cr\u00e9ation de l'\u00e9cran de d\u00e9tail. Voir page de d\u00e9tail // app/views/movies/movie-list/popin.jsx // Libs import React , { PropTypes } from react ; import { translate } from focus-core/translation ; // Components import Panel from focus-components/components/panel ; import { component as Popin } from focus-components/components/popin ; export function MoviePopin ({ id , isOpen , onPopinClose }) { return ( Popin open = { isOpen } onPopinClose = { onPopinClose } h4 { translate ( movie.popin.title )} /h4 div { `Popin d \u00e9dition pour le film ${ id } ` } /div { /* Affichage du formulaire de d\u00e9tail */ } /Popin ); } MoviePopin . propTypes = { id : PropTypes . number , isOpen : PropTypes . boolean . isRequired , onPopinClose : PropTypes . func . isRequired }; Cette poin doit maintenant \u00eatre ajout\u00e9e dans le composant principal de la liste . // app/views/movies/movie-list/index.jsx // Libs import React from react ; // Actions import { movieActions } from ../../../actions/movies ; // Components import { MovieList } from ./movie-list ; import { MovieCriteria } from ./movie-criteria ; +++ import { MoviePopin } from ./movie-popin ; function onFilterChange(title) { moviesActions.searchMovies.updateProperties({ criteria: { title } }); } export const MovieListPage = React.createClass({ +++ getInitialState() { +++ return { id: undefined }; +++ }, +++ onPopinClose() { +++ this.setState({ id: undefined }); +++ }, +++ openPopin(id) { +++ this.setState({ id }); +++ }, render() { return ( MovieCriteria onFilterChange={onFilterChange} / --- MovieList onLineClick={() = { /* RAF */ }} / +++ MovieList onLineClick={id = this.openPopin(id)} / --- div Popin de preview d un film /div +++ MoviePopin +++ id={this.state.id} +++ isOpen={this.state.id !== undefined} +++ onPopinClose={() = this.onPopinClose()} +++ / ); } }); Nous avons fait les modifications suivante : Ajout d'un state pour savoir l'identifiant du movie sur lequel on a cliqu\u00e9 Donn\u00e9 la m\u00e9thode openPopin au composant MovieList pour ouvrir la popin Donn\u00e9 la m\u00e9thode onPopinClose au composant MoviePopin pour fermer la popin Ici, le trick est d'utiliser la propri\u00e9t\u00e9 id pour savoir si la popin est ouverte ou ferm\u00e9e.","title":"Cr\u00e9ation de la popin d'\u00e9dition"},{"location":"tutorials/liste-page/#epilogue","text":"","title":"Epilogue"}]}